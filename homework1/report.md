# 41143154

作業一

## 解題說明

本作業包含兩個主要問題：

### 問題一：Ackermann 函數優化
Ackermann 函數是一個經典的遞迴函數，定義如下：
```
A(m, n) = {
    n + 1,                   if m = 0
    A(m-1, 1),               if m > 0 and n = 0
    A(m-1, A(m, n-1)),       if m > 0 and n > 0
}
```

#### 解題策略
1. **原始實作**：直接按照數學定義實現遞迴版本
2. **優化實作**：使用 Memoization 技術，透過動態矩陣儲存已計算結果
3. **動態記憶體管理**：當矩陣容量不足時，自動擴展存儲空間

### 問題二：Power Set 生成
Power Set 是指一個集合的所有子集合所組成的集合。

#### 解題策略
1. **遞迴版本**：用 Decrease and Conquer 概念，每次移除一個元素，逐步構建冪集
2. **迭代版本**：使用 Bit Masking 技術，直接生成所有子集
3. **矩陣存儲**：使用自定義矩陣結構存儲所有子集

## 程式實作

### 問題一：Ackermann 函數

#### 核心數據結構
```cpp
typedef struct {
    int32_t *data;
    int32_t rows; 
    int32_t cols; 
    int32_t capacity;
    int32_t extend_ratio;
} MatrixList;
```

#### 關鍵函數實現
1. **記憶化查表機制**：
   - `get_from_table()`: 檢查是否已計算過
   - `store_to_table()`: 儲存計算結果
   - `extend_matrix()`: 動態擴展矩陣容量

2. **優化版本**：
   ```cpp
   int32_t ackermann_function_optimize(int32_t m, int32_t n) {
       if (m < 0 || n < 0) {
           return INVALID_VALUE;
       }
       
       int32_t cached_value = get_from_table(m, n);
       if (cached_value != NOT_COMPUTED) {
           return cached_value;
       }
       
       // 計算並存儲結果
       int32_t result;
       if (m == 0) {
           result = n + 1;
       } else if (m > 0 && n == 0) {
           result = ackermann_function_optimize(m - 1, 1);
       } else {
           result = ackermann_function_optimize(m - 1, ackermann_function_optimize(m, n - 1));
       }
       
       store_to_table(m, n, result);
       return result;
   }
   ```

### 問題二：Power Set 生成

#### 核心數據結構
```cpp
typedef struct {
    MatrixList* matrix;
    int32_t* subset_sizes;
    int32_t subset_count;
    int32_t max_subset_size;
} PowerSetMatrix;
```

#### 關鍵演算法實現
1. **遞迴版本**：
   <!-- - 使用分治法，先處理較小的子集合 -->
   - 對每個現有子集，生成包含當前元素的新子集

2. **迭代版本**：
   ```cpp
   PowerSetMatrix* powerset_matrix_iterative(int32_t* set, int32_t set_size) {
       int32_t total_subsets = 1 << set_size;
       PowerSetMatrix* result = new_powerset_matrix(total_subsets, set_size > 0 ? set_size : 1);
       
       for (int32_t mask = 0; mask < total_subsets; mask++) {
           ArrayList* temp_subset = new_list();
           
           for (int32_t i = 0; i < set_size; ++i) {
               if (mask & (1 << i)) {
                   add(temp_subset, set[i]);
               }
           }
           
           int32_t* subset_array = to_array(temp_subset);
           add_subset_to_powerset(result, subset_array, size(temp_subset));
           
           if (subset_array != NULL) {
               free(subset_array);
           }
           delete_list(temp_subset);
       }
       
       return result;
   }
   ```

## 效能分析

### 問題一：Ackermann 函數效能比較

#### 時間複雜度分析
- **原始版本**：無法用傳統 Big-O 表示法準確描述，屬於 NONELEMENTARY 複雜度類
- **記憶化版本**：仍然是指數級複雜度，但在有重複子問題時能顯著減少計算量

#### 空間複雜度分析
- **原始版本**：$O(A(m,n))$（遞迴堆疊深度）
- **記憶化版本**：$O(\text{實際計算的 }(m,n)\text{ 對數量})$（矩陣存儲空間）

#### 實測結果與問題分析

**測試案例 A(3,6)：**
```
1. 帶記憶化版本: 結果: 509, 時間: 0.002999 秒
2. 原始版本: 結果: 509, 時間: 0.001074 秒
```

**意外發現：原始版本比記憶化版本更快！**

**測試案例 A(4,2)：**
```
1. 帶記憶化版本: Segmentation fault (core dumped)
2. 原始版本: Segmentation fault (core dumped)
```

### 問題二：Power Set 生成效能比較

#### 時間複雜度分析
- **遞迴版本**：$O(n \times 2^n)$，需要為每個子集進行複製操作
- **迭代版本**：$O(n \times 2^n)$，但常數因子較小

#### 空間複雜度分析
- **兩個版本**：$O(n \times 2^n)$，需要存儲所有子集

#### 實測結果與分析

**小規模測試（集合大小 3）：**
```
遞迴版本：0.000002 秒，8 個子集
迭代版本：0.000001 秒，8 個子集
結果一致性：一致
```

**中規模測試（集合大小 4）：**
```
遞迴版本：0.000002 秒，16 個子集
迭代版本：0.000002 秒，16 個子集
結果一致性：一致
```

**矩陣表示效果：**
集合 {1, 2, 3} 的冪集在矩陣中的表示：
```
矩陣大小: 8 x 3
  [  -1,   -1,   -1]  // 空集 {}
  [   3,   -1,   -1]  // {3}
  [   2,   -1,   -1]  // {2}
  [   2,    3,   -1]  // {2,3}
  [   1,   -1,   -1]  // {1}
  [   1,    3,   -1]  // {1,3}
  [   1,    2,   -1]  // {1,2}
  [   1,    2,    3]  // {1,2,3}
```

**演算法正確性驗證：**
- 預期子集數：$2^n$，實際結果完全符合
- 遞迴版本和迭代版本產生相同結果
- 涵蓋所有可能的子集組合

## 測試與驗證

### 問題一測試結果
```
Testing Ackermann(5, 0):
original version:
Result: 13
Time: 1.979833 sec

optimize version:
Result: 13
Time: 0.066116 sec

Consistent results: Yes
```

### 問題二測試結果

#### 基本功能測試
```
測試集合 {1, 2, 3}:
PowerSet with 8 subsets:
{ {}, {3}, {2}, {2,3}, {1}, {1,3}, {1,2}, {1,2,3} }

測試空集:
PowerSet with 1 subsets:
{ {} }

測試單元素集合 {5}:
PowerSet with 2 subsets:
{ {}, {5} }

測試較大集合 {1,2,3,4}:
PowerSet with 16 subsets:
{ {}, {4}, {3}, {3,4}, {2}, {2,4}, {2,3}, {2,3,4}, 
  {1}, {1,4}, {1,3}, {1,3,4}, {1,2}, {1,2,4}, {1,2,3}, {1,2,3,4} }
```

#### 遞迴過程分析
以集合 {1,2} 為例的遞迴過程：
```
powerset({1,2}):
  1. first = 1, rest = {2}
  2. 遞歸計算 powerset({2}):
     - first = 2, rest = {}
     - powerset({}) = {{}}
     - 不含 2: {{}}
     - 含 2: {{2}}
     - 返回: {{}, {2}}
  3. 不含 1: {{}, {2}}
  4. 含 1: {{1}, {1,2}}
  5. 最終結果: {{}, {2}, {1}, {1,2}}
```

#### 資料結構測試
**ArrayList 操作展示：**
```
創建空 ArrayList，容量：10，大小：0
添加元素後: [10, 20, 30, 40, 50]
獲取索引 2 的元素：30
設置索引 2 為 999 後: [10, 20, 999, 40, 50]
在索引 1 插入 555 後: [10, 555, 20, 999, 40, 50]
移除索引 3 的元素 999 後: [10, 555, 20, 40, 50]
```

**MatrixList 功能展示：**
```
創建 3x4 矩陣填充後:
  [   0,    1,    2,    3]
  [  10,   11,   12,   13]
  [  20,   21,   22,   23]

擴展到 4x5 後:
  [   0,    1,    2,    3,    0]
  [  10,   11,   12,   13,    0]
  [  20,   21,   22,   23,    0]
  [   0,    0,    0,    0,    0]
```

### 編譯與執行指令
建構請使用Ubuntu或WSL: 
```bash
# 問題一
$ cd homework1/src/problem-1
$ make run

# 問題二  
$ cd homework1/src/problem-2
$ make run
```

## 申論及開發報告

### 記憶化技術的應用與問題

在 Ackermann 函數的優化中，記憶化技術的表現出乎意料：

#### 遇到的主要問題

**問題一：小測試案例中記憶化反而較慢**

測試 A(3,6) 時發現：
- 記憶化版本：0.002999 秒
- 原始版本：0.001074 秒

**原因分析：**
1. **測試案例太小**：A(3,6) 對現代電腦來說計算量很小
2. **記憶化的額外開銷**：
   - 每次遞迴都要檢查表格
   - 需要計算索引位置
   - 需要存儲結果到表格
   - 這些開銷比直接計算還要大

**問題二：大測試案例導致記憶體問題**

測試 A(4,2) 時出現 Segmentation fault：
```
A(4,2) = A(3, A(4,1))
       = A(3, 65533)
```

**根本問題：A(4,2) 的計算模式對記憶化不友好**

```
A(3, 65533) = A(2, A(3, 65532))
A(3, 65532) = A(2, A(3, 65531))
A(3, 65531) = A(2, A(3, 65530))
...
```

關鍵觀察：**每個 A(3,k) 都只被計算一次，沒有重複！**

**為什麼記憶化失效：**
1. **線性依賴**：A(4,2) → A(3,65533) → A(3,65532) → ... → A(3,1)
2. **無重複子問題**：每個中間值只計算一次
3. **記憶體爆炸**：需要存儲 65533 個不同的值
4. **記憶體分配開銷**：頻繁的表格擴展比直接計算還慢

**記憶化的時間複雜度誤解：**
- 記憶化版本的時間複雜度**不是** $O(m \times n)$
- 根據學術研究，迭代演算法的時間複雜度是 $O(i \cdot A(i,n))$，仍然是指數級
- 記憶化只在有大量重複子問題時才有效，而 Ackermann 函數的計算路徑通常缺乏這種重複性

#### 記憶化的正確應用場景

**適合的情況：大量重複子問題**
```cpp
// 批量計算 A(3,1) 到 A(3,10)
// A(3,5) 會重複使用 A(3,1) 到 A(3,4) 的結果
for (int i = 1; i <= 10; i++) {
    result = ackermann_memo(3, i);
}
```

**不適合的情況：單一大值計算**
```cpp
// 只計算一個大值，沒有重複子問題可以利用
ackermann_memo(4, 2);
```

#### 記憶化優化的限制

1. **不是萬能解決方案**：記憶化只在有重複子問題時才有效
2. **空間時間權衡**：需要大量記憶體存儲中間結果
3. **問題結構依賴**：Ackermann 函數的特殊性質使某些計算路徑無法從記憶化中受益

### 位元運算在 Power Set 生成中的應用

1. **直觀的映射關係**：每個位元對應一個集合元素，1 表示包含，0 表示不包含
2. **高效的遍歷**：從 0 到 $2^n-1$ 的遍歷恰好對應所有可能的子集
3. **位元運算效率**：位元運算比傳統的遞迴方法更高效

#### Power Set 生成的成功案例

與 Ackermann 函數的記憶化問題不同，Power Set 的兩種實現都表現良好：

**成功的原因：**
1. **問題規模可控**：$2^n$ 的增長雖然快，但在小到中等規模下仍可處理
2. **演算法複雜度匹配**：兩種演算法的時間複雜度都是 $O(n \times 2^n)$，符合問題本質
3. **記憶體使用合理**：矩陣存儲結構有效管理子集數據

**性能比較結果：**
- 小規模測試中，迭代版本略快於遞迴版本
- 兩種方法都能正確生成所有子集
- 矩陣表示法提供了清晰的數據結構

#### 遞迴 vs 迭代的實際表現

**遞迴版本優勢：**
- 邏輯清晰，易於理解
- 符合分治思想
- 程式碼結構優雅

**迭代版本優勢：**
- 避免函數呼叫開銷
- 記憶體使用更穩定
- 略微更快的執行速度

**共同特點：**
- 都能正確處理邊界情況（空集、單元素集合）
- 結果完全一致
- 在小到中等規模下表現都很好

### 資料結構設計考量

1. **矩陣存儲結構**：
   - 使用一維陣列模擬二維矩陣，提高記憶體存取效率
   - 實現動態擴展功能，適應不同規模的問題

2. **動態陣列**：
   - 提供自動擴容機制，避免固定大小限制
   - 實現基本的陣列操作，支援各種演算法需求

### 記憶體管理

程式中特別注意記憶體管理問題：

1. **動態分配與釋放**：確保所有動態分配的記憶體都能正確釋放
2. **錯誤處理**：在記憶體分配失敗時提供適當的錯誤處理
3. **避免記憶體洩漏**：透過結構化的記憶體管理機制防止記憶體洩漏

### 複雜度分析的修正與深入理解

#### 問題一：Ackermann 函數複雜度的正確認識

- **原始版本時間複雜度**：屬於 NONELEMENTARY 複雜度類，無法用傳統 Big-O 準確描述
- **記憶化版本時間複雜度**：根據學術研究，迭代演算法的時間複雜度是 $O(i \cdot A(i,n))$，仍然是指數級
- **空間複雜度**：取決於實際需要存儲的 $(m,n)$ 對數量，而不是簡單的 $O(m \times n)$

#### 問題二：Power Set 複雜度分析

- **時間複雜度**：$O(n \times 2^n)$ 
- **空間複雜度**：$O(n \times 2^n)$ 

### 學習心得

1. **理論與實踐的差距**：理論上的優化在實際應用中可能受到各種因素影響
2. **問題特性的重要性**：不同的問題結構決定了優化策略的適用性
3. **測試的重要性**：需要多樣化的測試案例來全面評估演算法性能
4. **記憶化的雙面性**：記憶化是強大的技術，但也有其適用限制

#### 對比分析：兩個問題的不同表現

**Problem 1 (Ackermann)：理論與實踐的落差**
- 理論上記憶化應該有優勢，但實際測試發現問題
- 小測試案例中記憶化反而更慢
- 大測試案例中記憶化導致記憶體問題
- 問題結構不適合記憶化（缺乏重複子問題）

**Problem 2 (Power Set)：理論與實踐的一致**
- 兩種演算法都表現良好
- 性能符合理論預期
- 數據結構設計合理，支持各種規模的測試
- 遞迴和迭代版本各有優勢

#### 重要發現

1. **演算法適用性至關重要**：
   - 記憶化不是萬能的，需要分析問題結構
   - Ackermann 函數的線性依賴特性使記憶化失效
   - Power Set 的問題結構適合兩種實現方式

2. **測試案例的重要性**：
   - 小測試案例可能隱藏問題
   - 大測試案例可能暴露記憶體問題
   - 需要多樣化的測試來全面評估

3. **數據結構設計的影響**：
   - 自製的 MatrixList 和 ArrayList 在 Power Set 中表現良好
   - 動態擴展功能在適當的場景下很有用
   - 記憶體管理需要仔細設計

這次經驗讓我明白，在程式設計中，「紙上談兵」的理論分析必須結合實際測試，才能得出真正有價值的結論。記憶化技術雖然在理論上能夠大幅提升效能，但在實際應用中必須考慮問題的特性、測試案例的規模，以及記憶化本身的開銷。同時，Power Set 的成功實現也證明了，當演算法與問題特性匹配時，理論與實踐可以完美結合。
